---
title: <canvas vs svg>
date: <2021/10/24>
tags: 
    - <前端>
    - <D届>
author: <dogcat-ux>  
---

## 前言

一直对于canvas和svg这二者的作用和关系一知半解，就借着博客梳理梳理，若有错误欢迎指出~

## 一.Canvas

Canvas是HTML5的画布，它公开了一个或多个渲染上下文。

画布本身就是张白纸，你可以移动纸张改变纸张大小（设置画布边距长宽），也可以在纸张里面绘制图像（在画布中操作）。

#### 用法

canvas在body里面定义，用js在画布上面画画。当然canvas本身就是一个标签，所以你也可以给它设置长宽背景色等。

```
<body>
<canvas id="canvas"></canvas>
<script>
//获取canvas元素
  const canvas = document.getElementById('canvas');
  //创建context对象
  const ctx = canvas.getContext('2d');
  //绘制一个绿色的矩形
  ctx.fillStyle = 'green';
  ctx.fillRect(10, 10, 150, 100);
</script>
</body>
```

canvas可以绘制矩形圆形等各种图像，也可以直接使用图片，canvas中使用图片必须等img完全加载后才能呈递图片。具体的画画操作不详细说明。

##### canvas坐标

左上角为画布原点，向右延伸为x方向，向下延伸为Y方向。（2d画布）

## 二.SVG

svg全称**Scalable Vector Graphics**，意为可缩放矢量图形

svg是一种使用XML描述2D图形的语言。那我们只能去看下xml了，xml简单介绍在下面。

SVG 基于 XML，这意味着 SVG DOM 中的每个元素都是可用的。您可以为某个元素附加 JavaScript 事件处理器。

在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。

#### SVG in html

svg本身可以下载，并且可以用浏览器打开。

##### html

SVG 文件可通过以下标签嵌入 HTML 文档：<embed>、<object> 或者 <iframe>。

##### html5

在 HTML5 中，能够将 SVG 元素直接嵌入 HTML 页面中

#### 用法

SVG的形状什么的就不多说了，svg可以绘制矩形，圆形什么的。像前端用到的图标就可以用svg代码书写出来。

##### 滤镜

这边讲一下svg的滤镜。当然css的filter本身也可以进行图像处理。

<filter> 标签用来定义 SVG 滤镜。<filter> 标签使用必需的 id 属性来定义向图形应用哪个滤镜。

<filter> 标签必须嵌套在 <defs> 标签内。<defs> 标签是 definitions 的缩写，它允许对诸如滤镜等特殊元素进行定义。

```
<svg width="100%" height="100%" version="1.1"
     xmlns="http://www.w3.org/2000/svg">

<!--    在这边定义-->
    <defs>
        <filter id="Gaussian_Blur">
            <feGaussianBlur in="SourceGraphic" stdDeviation="3" />
        </filter>
    </defs>

<!--    在这边用css的形式添加滤镜-->
    <rect width="300" height="100"
          style="fill:rgb(0,0,0);stroke-width:1;
stroke:rgb(0,0,0);filter:url(#Gaussian_Blur)"/>

</svg>
```

html5中我们可以直接使用svg元素，这样

```
<div class="svgFilter"></div>
<!--定义滤镜-->
<svg>
  <defs>
    <filter id="blur">
      <feGaussianBlur in="SourceGraphic" stdDeviation="5"/>
    </filter>
  </defs>
</svg>

//使用滤镜
    .svgFilter{
      filter: url(#blur);
    }
```

###### 滤镜标签通用属性

有一些属性是每一个滤镜标签都有，都可以进行设置的。

| 属性          | 作用                                                         |
| ------------- | ------------------------------------------------------------ |
| x, y          | 提供左上角的坐标来定义在哪里渲染滤镜效果。 （默认值：0）     |
| width, height | 绘制滤镜容器框的高宽（默认都为 100%）                        |
| result        | 用于定义一个滤镜效果的输出名字，以便将其用作另一个滤镜效果的输入（in） |
| in            | 指定滤镜效果的输入源，可以是某个滤镜导出的 `result`，也可以是下面 6 个值 |

关于svg滤镜还有很多很炫酷的效果，还可以通过矩阵数值自定义滤镜色彩效果，这里不深入讲解，有兴趣可以自己去了解。

## 三.xml

#### 定义

xml指可扩展标记语言。

xml被设计用来存储数据，不显示数据。

XML 需要自行定义标签，且标签名称具有自我描述性。
XML 是 W3C 推荐的数据传输存放标准。

#### 用途

1.可以作为一种简单的数据库，存储并且检索数据。

2.传输约定格式的文件。

3.做软件的配置文件。

#### 诞生

![image-20211024104853398](C:\Users\黄巧丽\AppData\Roaming\Typora\typora-user-images\image-20211024104853398.png)

XML的前身是**SGML**（The **S**tandard **G**eneralized **M**arkup **L**anguage），xml的诞生是因为

1.SGML过于庞大复杂

2.为了解决HTML的问题

- 不能解决所有解释资料的问题 - 像是影音档或化学公式、音乐符号等其他形态的内容。
- 性能问题 - 需要下载整份文件，才能开始对文件做搜索。
- 扩展性、弹性、易读性均不佳。

XML是在一个这样的背景下诞生的——为了有一个更中立的方式，让客户端自行决定要如何消化、呈现从服务端所提供的信息。

**XML被广泛用来作为跨平台之间交互数据的形式**，主要针对数据的内容，通过不同的格式化描述手段（XSLT，CSS等）可以完成最终的形式表达（生成对应的HTML，PDF或者其他的文件格式）。



#### 和html的对比

|                | html             | xml                                   |
| -------------- | ---------------- | ------------------------------------- |
| 作用           | 显示数据         | 传输和存储数据                        |
| 语法           | 略               | 要求嵌套，配对，并且遵循DTD的树形结构 |
| 空格           | 多个时只显示一个 | 输入几个显示几个                      |
| 与数据库的关系 | 无直接联系       | 与关系型和层状数据库均可对应和转换    |
| 大小写敏感     | 不区分           | 区分                                  |

可以通过JavaScript 来解析xml并访问DOM

## 四.SVG与Canvas两者的区别

二者其实从根本上来讲不是同一个级别上的东西。

canvas本身是h5的一个标签，而svg它是一种使用XML描述2D图形的语言，个人理解非要说的话svg的量级应该是类似于html的量级的，毕竟svg可以下载可以直接用浏览器打开的。

svg可以直接利用css对图形进行改变，canvas不能（画布内只能用js操作）。

|          | svg                                                          | canvas                                                       |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 渲染方式 | 在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。 | 在 canvas 中，一旦图形被绘制完成，它就不会继续得到浏览器的关注。如果其位置发生变化，那么整个场景也需要重新绘制，包括任何或许已被图形覆盖的对象。 |
| 特点     | 矢量，xml，css，元素操作                                     | 像素，只能脚本驱动                                           |
| 功能     | 功能丰富，各种图形，滤镜，动画等                             | 功能简单，2D绘图API                                          |
| 操作对象 | 基于图形元素                                                 | 基于像素                                                     |
| 驱动     | 支持脚本和css                                                | 只能脚本驱动                                                 |
| 事件交互 | 用户交互到图形元素(rect,path)                                | 用户交互到像素点（x,y）                                      |
| 速度     | 较慢                                                         | 更快                                                         |
| 适合用途 | 适合带有大型渲染区域的应用程序（比如谷歌地图）               | 最适合图像密集型的游戏，其中的许多对象会被频繁重绘           |
| 输出图形 | 矢量图形（放大不会失真或者锯齿）                             | 标量画布（放大会失真或者锯齿）                               |

![image-20211026104709317](C:\Users\黄巧丽\AppData\Roaming\Typora\typora-user-images\image-20211026104709317.png)

